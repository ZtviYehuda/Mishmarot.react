==== FILE: .env ====
FLASK_APP=run.py
FLASK_DEBUG=1
JWT_SECRET_KEY=change_this_to_a_complex_secret_key
DB_HOST=localhost
DB_NAME=postgres
DB_USER=postgres
DB_PASS=8245

==== FILE: app\config.py ====
import os
from dotenv import load_dotenv
from datetime import timedelta

# טעינת משתני סביבה מקובץ .env
load_dotenv()

class Config:
    # הגדרות אבטחה
    JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'dev_secret')
    JWT_ACCESS_TOKEN_EXPIRES = timedelta(hours=12) # הטוקן תקף ל-12 שעות
    
    # הגדרות מסד נתונים
    DB_HOST = os.getenv('DB_HOST')
    DB_NAME = os.getenv('DB_NAME')
    DB_USER = os.getenv('DB_USER')
    DB_PASS = os.getenv('DB_PASS')

==== FILE: app\models\attendance_model.py ====
from app.utils.db import get_db_connection
from psycopg2.extras import RealDictCursor
from datetime import datetime


class AttendanceModel:
    @staticmethod
    def log_status(
        employee_id,
        status_type_id,
        note=None,
        reported_by=None,
        start_date=None,
        end_date=None,
    ):
        conn = get_db_connection()
        if not conn:
            return False
        try:
            cur = conn.cursor()
            cur.execute(
                """
                UPDATE attendance_logs 
                SET end_datetime = CURRENT_TIMESTAMP 
                WHERE employee_id = %s AND end_datetime IS NULL
            """,
                (employee_id,),
            )

            start = start_date if start_date else datetime.now()
            cur.execute(
                """
                INSERT INTO attendance_logs (employee_id, status_type_id, start_datetime, end_datetime, note, reported_by)
                VALUES (%s, %s, %s, %s, %s, %s)
            """,
                (employee_id, status_type_id, start, end_date, note, reported_by),
            )
            conn.commit()
            return True
        except Exception as e:
            conn.rollback()
            print(f"Error logging status: {e}")
            return False
        finally:
            conn.close()

    @staticmethod
    def get_status_types():
        conn = get_db_connection()
        if not conn:
            return []
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            cur.execute(
                "SELECT id, name, color, is_presence FROM status_types ORDER BY id"
            )
            return cur.fetchall()
        finally:
            conn.close()

    @staticmethod
    def get_monthly_summary(year, month):
        conn = get_db_connection()
        if not conn:
            return {}
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            query = """
                SELECT 
                    DATE(al.start_datetime) as date,
                    st.name as status,
                    st.color,
                    COUNT(*) as count
                FROM attendance_logs al
                JOIN status_types st ON al.status_type_id = st.id
                WHERE EXTRACT(YEAR FROM al.start_datetime) = %s 
                AND EXTRACT(MONTH FROM al.start_datetime) = %s
                GROUP BY date, st.name, st.color
                ORDER BY date
            """
            cur.execute(query, (year, month))
            rows = cur.fetchall()
            summary = {}
            for row in rows:
                d = str(row["date"])
                if d not in summary:
                    summary[d] = []
                summary[d].append(row)
            return summary
        finally:
            conn.close()

    @staticmethod
    def get_dashboard_stats():
        conn = get_db_connection()
        if not conn:
            return []
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            query = """
                SELECT 
                    COALESCE(st.name, 'משרד') as status_name,
                    COUNT(e.id) as count,
                    COALESCE(st.color, '#22c55e') as color
                FROM employees e
                LEFT JOIN LATERAL (
                    SELECT status_type_id FROM attendance_logs 
                    WHERE employee_id = e.id AND end_datetime IS NULL
                    ORDER BY start_datetime DESC LIMIT 1
                ) last_log ON true
                LEFT JOIN status_types st ON last_log.status_type_id = st.id
                WHERE e.is_active = TRUE
                GROUP BY st.name, st.color
            """
            cur.execute(query)
            return cur.fetchall()
        finally:
            conn.close()

    @staticmethod
    def get_birthdays():
        conn = get_db_connection()
        if not conn:
            return []
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            query = """
                SELECT first_name, last_name, birth_date,
                    DATE_PART('day', birth_date) as day,
                    DATE_PART('month', birth_date) as month
                FROM employees
                WHERE is_active = TRUE AND birth_date IS NOT NULL
                AND (
                    (EXTRACT(DOY FROM birth_date) - EXTRACT(DOY FROM CURRENT_DATE) + 365) % 365 < 7
                )
                ORDER BY month, day
            """
            cur.execute(query)
            return cur.fetchall()
        finally:
            conn.close()


==== FILE: app\models\employee_model.py ====
from app.utils.db import get_db_connection
from werkzeug.security import check_password_hash, generate_password_hash
from psycopg2.extras import RealDictCursor


class EmployeeModel:
    @staticmethod
    def login_check(personal_number, password_input):
        conn = get_db_connection()
        if not conn:
            return None
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            query = """
                SELECT id, first_name, last_name, personal_number, 
                       password_hash, must_change_password, is_admin, is_commander, national_id
                FROM employees 
                WHERE personal_number = %s AND is_active = TRUE
            """
            cur.execute(query, (personal_number,))
            user = cur.fetchone()

            if user:
                is_valid = False
                # Check actual password hash
                if user["password_hash"] and check_password_hash(
                    user["password_hash"], password_input
                ):
                    is_valid = True
                # Check initial password (national_id) if forced change is required
                elif user["must_change_password"] and str(user["national_id"]) == str(
                    password_input
                ):
                    is_valid = True

                if is_valid:
                    del user["password_hash"]
                    return user
            return None
        finally:
            conn.close()

    @staticmethod
    def get_employee_by_id(emp_id):
        conn = get_db_connection()
        if not conn:
            return None
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            query = """
                SELECT e.*, 
                       COALESCE(d.name, d2.name, d3.name, d_cmd.name) as department_name, 
                       COALESCE(s.name, s2.name, s_cmd.name) as section_name, 
                       COALESCE(t.name, t_cmd.name) as team_name,
                       st.name as status_name, 
                       st.color as status_color,
                       r.name as role_name
                FROM employees e
                -- Structure Joins
                LEFT JOIN teams t ON e.team_id = t.id
                LEFT JOIN sections s ON t.section_id = s.id
                LEFT JOIN departments d ON s.department_id = d.id
                -- Commander Structure Joins
                LEFT JOIN teams t_cmd ON t_cmd.commander_id = e.id
                LEFT JOIN sections s2 ON t_cmd.section_id = s2.id 
                LEFT JOIN departments d3 ON s2.department_id = d3.id
                LEFT JOIN sections s_cmd ON s_cmd.commander_id = e.id
                LEFT JOIN departments d2 ON s_cmd.department_id = d2.id
                LEFT JOIN departments d_cmd ON d_cmd.commander_id = e.id
                LEFT JOIN roles r ON e.role_id = r.id
                -- Active Status
                LEFT JOIN attendance_logs al ON al.employee_id = e.id AND al.end_datetime IS NULL
                LEFT JOIN status_types st ON al.status_type_id = st.id
                WHERE e.id = %s
            """
            cur.execute(query, (emp_id,))
            return cur.fetchone()
        finally:
            conn.close()

    @staticmethod
    def get_all_employees(filters=None):
        conn = get_db_connection()
        if not conn:
            return []
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            query = """
                SELECT e.id, e.first_name, e.last_name, e.personal_number, e.phone_number,
                       e.birth_date, e.is_commander,
                       COALESCE(t.name, 'מטה') as team_name, 
                       COALESCE(s.name, 'מטה') as section_name, 
                       COALESCE(d.name, 'מטה') as department_name,
                       COALESCE(st.name, 'משרד') as status_name,
                       COALESCE(st.color, '#22c55e') as status_color
                FROM employees e
                LEFT JOIN teams t ON e.team_id = t.id
                LEFT JOIN sections s ON t.section_id = s.id
                LEFT JOIN departments d ON s.department_id = d.id
                LEFT JOIN LATERAL (
                    SELECT status_type_id FROM attendance_logs 
                    WHERE employee_id = e.id AND end_datetime IS NULL
                    ORDER BY start_datetime DESC LIMIT 1
                ) last_log ON true
                LEFT JOIN status_types st ON last_log.status_type_id = st.id
                WHERE e.is_active = TRUE
            """
            params = []
            if filters:
                if filters.get("search"):
                    term = f"%{filters['search']}%"
                    query += " AND (e.first_name ILIKE %s OR e.last_name ILIKE %s OR e.personal_number ILIKE %s)"
                    params.extend([term, term, term])
                if filters.get("dept_id"):
                    query += " AND d.id = %s"
                    params.append(filters["dept_id"])

            query += " ORDER BY e.first_name ASC"
            cur.execute(query, tuple(params))
            return cur.fetchall()
        finally:
            conn.close()

    @staticmethod
    def create_employee(data):
        conn = get_db_connection()
        if not conn:
            return False
        try:
            cur = conn.cursor()
            pw_hash = None
            must_change = False
            if data.get("is_commander") or data.get("is_admin"):
                pw_hash = generate_password_hash(str(data["national_id"]))
                must_change = True

            query = """
                INSERT INTO employees (
                    first_name, last_name, personal_number, national_id, phone_number,
                    city, birth_date, enlistment_date, discharge_date,
                    team_id, role_id, is_commander, is_admin, 
                    password_hash, must_change_password, security_clearance, police_license
                ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                RETURNING id
            """
            cur.execute(
                query,
                (
                    data["first_name"],
                    data["last_name"],
                    data["personal_number"],
                    data["national_id"],
                    data.get("phone_number"),
                    data.get("city"),
                    data.get("birth_date"),
                    data.get("enlistment_date"),
                    data.get("discharge_date"),
                    data.get("team_id"),
                    data.get("role_id"),
                    data.get("is_commander", False),
                    data.get("is_admin", False),
                    pw_hash,
                    must_change,
                    data.get("security_clearance", 0),
                    data.get("police_license", False),
                ),
            )
            new_id = cur.fetchone()[0]
            conn.commit()
            return new_id
        except Exception as e:
            conn.rollback()
            print(f"Error creating employee: {e}")
            raise e
        finally:
            conn.close()

    @staticmethod
    def update_employee(emp_id, data):
        conn = get_db_connection()
        if not conn:
            return False
        try:
            cur = conn.cursor()
            query = """
                UPDATE employees 
                SET first_name = %s, last_name = %s, phone_number = %s, 
                    city = %s, birth_date = %s, enlistment_date = %s,
                    discharge_date = %s, team_id = %s, role_id = %s,
                    security_clearance = %s, emergency_contact = %s,
                    is_commander = %s, is_admin = %s
                WHERE id = %s
            """
            cur.execute(
                query,
                (
                    data["first_name"],
                    data["last_name"],
                    data["phone_number"],
                    data.get("city"),
                    data.get("birth_date"),
                    data.get("enlistment_date"),
                    data.get("discharge_date"),
                    data.get("team_id"),
                    data.get("role_id"),
                    data.get("security_clearance"),
                    data.get("emergency_contact"),
                    data.get("is_commander"),
                    data.get("is_admin"),
                    emp_id,
                ),
            )
            conn.commit()
            return True
        except Exception as e:
            conn.rollback()
            print(f"Error updating: {e}")
            return False
        finally:
            conn.close()

    @staticmethod
    def delete_employee(emp_id):
        conn = get_db_connection()
        if not conn:
            return False
        try:
            cur = conn.cursor()
            # Clean related data first
            cur.execute("DELETE FROM attendance_logs WHERE employee_id = %s", (emp_id,))
            cur.execute(
                "DELETE FROM transfer_requests WHERE employee_id = %s", (emp_id,)
            )

            # Unlink commanderships
            cur.execute(
                "UPDATE teams SET commander_id = NULL WHERE commander_id = %s",
                (emp_id,),
            )
            cur.execute(
                "UPDATE sections SET commander_id = NULL WHERE commander_id = %s",
                (emp_id,),
            )
            cur.execute(
                "UPDATE departments SET commander_id = NULL WHERE commander_id = %s",
                (emp_id,),
            )

            # Delete user
            cur.execute("DELETE FROM employees WHERE id = %s", (emp_id,))
            conn.commit()
            return True
        except Exception as e:
            conn.rollback()
            print(f"Error deleting: {e}")
            return False
        finally:
            conn.close()

    @staticmethod
    def update_password(user_id, new_password):
        conn = get_db_connection()
        if not conn:
            return False
        try:
            cur = conn.cursor()
            new_hash = generate_password_hash(new_password)
            cur.execute(
                "UPDATE employees SET password_hash = %s, must_change_password = FALSE WHERE id = %s",
                (new_hash, user_id),
            )
            conn.commit()
            return True
        except Exception:
            conn.rollback()
            return False
        finally:
            conn.close()

    @staticmethod
    def get_structure_tree():
        conn = get_db_connection()
        if not conn:
            return []
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            cur.execute("SELECT id, name FROM departments ORDER BY name")
            depts = cur.fetchall()
            cur.execute("SELECT id, name, department_id FROM sections ORDER BY name")
            sections = cur.fetchall()
            cur.execute("SELECT id, name, section_id FROM teams ORDER BY name")
            teams = cur.fetchall()

            structure = []
            for d in depts:
                dept_node = {**d, "sections": []}
                dept_sections = [s for s in sections if s["department_id"] == d["id"]]
                for s in dept_sections:
                    sect_node = {**s, "teams": []}
                    sect_teams = [t for t in teams if t["section_id"] == s["id"]]
                    sect_node["teams"] = sect_teams
                    dept_node["sections"].append(sect_node)
                structure.append(dept_node)
            return structure
        finally:
            conn.close()


==== FILE: app\models\transfer_model.py ====
from app.utils.db import get_db_connection
from psycopg2.extras import RealDictCursor


class TransferModel:
    @staticmethod
    def create_request(data, requester_id):
        conn = get_db_connection()
        if not conn:
            return False
        try:
            cur = conn.cursor()
            cur.execute(
                "SELECT id FROM transfer_requests WHERE employee_id = %s AND status = 'pending'",
                (data["employee_id"],),
            )
            if cur.fetchone():
                raise ValueError("Employee already has a pending transfer request")

            query = """
                INSERT INTO transfer_requests (employee_id, requester_id, target_type, target_id, notes, status)
                VALUES (%s, %s, %s, %s, %s, 'pending')
                RETURNING id
            """
            cur.execute(
                query,
                (
                    data["employee_id"],
                    requester_id,
                    data["target_type"],
                    data["target_id"],
                    data.get("notes"),
                ),
            )
            new_id = cur.fetchone()[0]
            conn.commit()
            return new_id
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            conn.close()

    @staticmethod
    def get_pending_requests():
        conn = get_db_connection()
        if not conn:
            return []
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            query = """
                SELECT tr.*, 
                       e.first_name, e.last_name, e.personal_number,
                       req.first_name as requester_first, req.last_name as requester_last,
                       CASE 
                           WHEN tr.target_type = 'department' THEN d.name
                           WHEN tr.target_type = 'section' THEN s.name  
                           WHEN tr.target_type = 'team' THEN t.name
                       END as target_name
                FROM transfer_requests tr
                JOIN employees e ON tr.employee_id = e.id
                JOIN employees req ON tr.requester_id = req.id
                LEFT JOIN departments d ON tr.target_type = 'department' AND tr.target_id = d.id
                LEFT JOIN sections s ON tr.target_type = 'section' AND tr.target_id = s.id
                LEFT JOIN teams t ON tr.target_type = 'team' AND tr.target_id = t.id
                WHERE tr.status = 'pending'
                ORDER BY tr.created_at DESC
            """
            cur.execute(query)
            return cur.fetchall()
        finally:
            conn.close()

    @staticmethod
    def approve_request(request_id, approver_id):
        conn = get_db_connection()
        if not conn:
            return False
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            cur.execute(
                "SELECT * FROM transfer_requests WHERE id = %s AND status = 'pending'",
                (request_id,),
            )
            req = cur.fetchone()
            if not req:
                return False

            if req["target_type"] == "team":
                cur.execute(
                    "UPDATE employees SET team_id = %s WHERE id = %s",
                    (req["target_id"], req["employee_id"]),
                )
            elif req["target_type"] == "section":
                cur.execute(
                    "SELECT id FROM teams WHERE section_id = %s LIMIT 1",
                    (req["target_id"],),
                )
                team_res = cur.fetchone()
                if team_res:
                    cur.execute(
                        "UPDATE employees SET team_id = %s WHERE id = %s",
                        (team_res["id"], req["employee_id"]),
                    )

            cur.execute(
                """
                UPDATE transfer_requests 
                SET status = 'approved', resolved_at = CURRENT_TIMESTAMP, resolved_by = %s 
                WHERE id = %s
            """,
                (approver_id, request_id),
            )
            conn.commit()
            return True
        except Exception as e:
            conn.rollback()
            return False
        finally:
            conn.close()

    @staticmethod
    def reject_request(request_id, approver_id, reason):
        conn = get_db_connection()
        if not conn:
            return False
        try:
            cur = conn.cursor()
            cur.execute(
                """
                UPDATE transfer_requests 
                SET status = 'rejected', resolved_at = CURRENT_TIMESTAMP, 
                    resolved_by = %s, rejection_reason = %s
                WHERE id = %s
            """,
                (approver_id, reason, request_id),
            )
            conn.commit()
            return True
        except Exception:
            conn.rollback()
            return False
        finally:
            conn.close()

    @staticmethod
    def cancel_request(request_id, user_id, is_admin=False):
        conn = get_db_connection()
        if not conn:
            return False
        try:
            cur = conn.cursor()
            check_q = "SELECT requester_id FROM transfer_requests WHERE id = %s AND status = 'pending'"
            cur.execute(check_q, (request_id,))
            res = cur.fetchone()

            if not res:
                return False
            if not is_admin and res[0] != user_id:
                return False

            cur.execute(
                "UPDATE transfer_requests SET status = 'cancelled', resolved_at = CURRENT_TIMESTAMP WHERE id = %s",
                (request_id,),
            )
            conn.commit()
            return True
        finally:
            conn.close()

    @staticmethod
    def get_history(limit=50):
        conn = get_db_connection()
        if not conn:
            return []
        try:
            cur = conn.cursor(cursor_factory=RealDictCursor)
            query = """
                SELECT tr.*, 
                       e.first_name, e.last_name, 
                       res_by.first_name as resolver_first
                FROM transfer_requests tr
                JOIN employees e ON tr.employee_id = e.id
                LEFT JOIN employees res_by ON tr.resolved_by = res_by.id
                WHERE tr.status IN ('approved', 'rejected', 'cancelled')
                ORDER BY tr.resolved_at DESC
                LIMIT %s
            """
            cur.execute(query, (limit,))
            return cur.fetchall()
        finally:
            conn.close()


==== FILE: app\models\__init__.py ====


==== FILE: app\routes\attendance_routes.py ====
from flask import Blueprint, jsonify, request
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models.attendance_model import AttendanceModel

att_bp = Blueprint("attendance", __name__)


@att_bp.route("/status-types", methods=["GET"])
@jwt_required()
def get_status_types():
    types = AttendanceModel.get_status_types()
    return jsonify(types)


@att_bp.route("/stats", methods=["GET"])
@jwt_required()
def get_stats():
    stats = AttendanceModel.get_dashboard_stats()
    birthdays = AttendanceModel.get_birthdays()
    return jsonify({"stats": stats, "birthdays": birthdays})


@att_bp.route("/log", methods=["POST"])
@jwt_required()
def log_status():
    data = request.get_json()
    current_user = get_jwt_identity()

    target_id = data.get("employee_id")
    if not target_id:
        target_id = current_user["id"]

    status_id = data.get("status_type_id")
    note = data.get("note")
    start_date = data.get("start_date")
    end_date = data.get("end_date")

    if not status_id:
        return jsonify({"error": "Missing status_type_id"}), 400

    success = AttendanceModel.log_status(
        employee_id=target_id,
        status_type_id=status_id,
        note=note,
        reported_by=current_user["id"],
        start_date=start_date,
        end_date=end_date,
    )

    if success:
        return jsonify({"success": True, "message": "הסטטוס עודכן"})
    return jsonify({"success": False, "error": "Failed to log status"}), 500


@att_bp.route("/calendar", methods=["GET"])
@jwt_required()
def get_calendar_stats():
    try:
        year = int(request.args.get("year"))
        month = int(request.args.get("month"))
        summary = AttendanceModel.get_monthly_summary(year, month)
        return jsonify(summary)
    except (ValueError, TypeError):
        return jsonify({"error": "Invalid year/month parameters"}), 400


==== FILE: app\routes\auth_routes.py ====
from flask import Blueprint, request, jsonify
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity
from app.models.employee_model import EmployeeModel

auth_bp = Blueprint("auth", __name__)


@auth_bp.route("/login", methods=["POST"])
def login():
    data = request.get_json()
    if not data:
        return jsonify({"error": "No data provided"}), 400

    p_num = data.get("personal_number")
    password = data.get("password")

    user = EmployeeModel.login_check(p_num, password)
    if user:
        # Create JWT Token
        identity = {
            "id": user["id"],
            "is_admin": user["is_admin"],
            "is_commander": user["is_commander"],
        }
        token = create_access_token(identity=str(user["id"]))

        return jsonify(
            {
                "success": True,
                "token": token,
                "user": {
                    "id": user["id"],
                    "first_name": user["first_name"],
                    "last_name": user["last_name"],
                    "personal_number": user["personal_number"],
                    "phone_number": user.get("phone_number"),
                    "must_change_password": user["must_change_password"],
                    "is_admin": user["is_admin"],
                    "is_commander": user["is_commander"],
                },
            }
        )
    return jsonify({"success": False, "error": "מספר אישי או סיסמה שגויים"}), 401


@auth_bp.route("/me", methods=["GET"])
@jwt_required()
def get_current_user():
    user_id = get_jwt_identity()
    user = EmployeeModel.get_employee_by_id(int(user_id))
    if user:
        return jsonify(
            {
                "id": user["id"],
                "first_name": user["first_name"],
                "last_name": user["last_name"],
                "personal_number": user["personal_number"],
                "phone_number": user.get("phone_number"),
                "must_change_password": user["must_change_password"],
                "is_admin": user["is_admin"],
                "is_commander": user["is_commander"],
            }
        )
    return jsonify({"error": "User not found"}), 404


@auth_bp.route("/change-password", methods=["POST"])
@jwt_required()
def change_password():
    user_id = get_jwt_identity()
    data = request.get_json()
    new_pass = data.get("new_password")

    if not new_pass or len(new_pass) < 6:
        return jsonify({"success": False, "error": "Password too short"}), 400

    if EmployeeModel.update_password(int(user_id), new_pass):
        return jsonify({"success": True, "message": "הסיסמה עודכנה בהצלחה"})
    return jsonify({"success": False, "error": "שגיאה בעדכון הסיסמה"}), 500


==== FILE: app\routes\employee_routes.py ====
from flask import Blueprint, jsonify, request, send_file
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models.employee_model import EmployeeModel
import pandas as pd
import io

emp_bp = Blueprint("employees", __name__)


@emp_bp.route("/", methods=["GET"])
@jwt_required()
def get_employees():
    filters = {
        "search": request.args.get("search"),
        "dept_id": request.args.get("dept_id"),
    }
    employees = EmployeeModel.get_all_employees(filters)
    return jsonify(employees)


@emp_bp.route("/<int:emp_id>", methods=["GET"])
@jwt_required()
def get_employee(emp_id):
    employee = EmployeeModel.get_employee_by_id(emp_id)
    if employee:
        return jsonify(employee)
    return jsonify({"error": "Not found"}), 404


@emp_bp.route("/", methods=["POST"])
@jwt_required()
def create_employee():
    current_user = get_jwt_identity()
    if not (current_user["is_admin"] or current_user["is_commander"]):
        return jsonify({"error": "Unauthorized"}), 403

    data = request.get_json()
    try:
        new_id = EmployeeModel.create_employee(data)
        return (
            jsonify({"success": True, "id": new_id, "message": "העובד נוצר בהצלחה"}),
            201,
        )
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 400


@emp_bp.route("/<int:emp_id>", methods=["PUT"])
@jwt_required()
def update_employee(emp_id):
    current_user = get_jwt_identity()
    if not (current_user["is_admin"] or current_user["is_commander"]):
        return jsonify({"error": "Unauthorized"}), 403

    data = request.get_json()
    if EmployeeModel.update_employee(emp_id, data):
        return jsonify({"success": True, "message": "User updated"})
    return jsonify({"success": False, "error": "Update failed"}), 500


@emp_bp.route("/<int:emp_id>", methods=["DELETE"])
@jwt_required()
def delete_employee(emp_id):
    current_user = get_jwt_identity()
    if not current_user["is_admin"]:
        return jsonify({"error": "Admins only"}), 403

    if EmployeeModel.delete_employee(emp_id):
        return jsonify({"success": True, "message": "User deleted"})
    return jsonify({"success": False, "error": "Delete failed"}), 500


@emp_bp.route("/structure", methods=["GET"])
@jwt_required()
def get_structure():
    tree = EmployeeModel.get_structure_tree()
    return jsonify(tree)


@emp_bp.route("/export", methods=["GET"])
@jwt_required()
def export_excel():
    employees = EmployeeModel.get_all_employees(request.args)
    df = pd.DataFrame(employees)

    columns = {
        "first_name": "שם פרטי",
        "last_name": "שם משפחה",
        "personal_number": "מספר אישי",
        "status_name": "סטטוס",
        "team_name": "צוות",
        "section_name": "מדור",
        "department_name": "מחלקה",
    }

    # Keep only relevant columns if they exist in DB response
    valid_cols = [c for c in columns.keys() if c in df.columns]
    df = df[valid_cols].rename(columns=columns)

    output = io.BytesIO()
    with pd.ExcelWriter(output, engine="openpyxl") as writer:
        df.to_excel(writer, index=False, sheet_name="Employees")

    output.seek(0)
    return send_file(
        output,
        download_name="report.xlsx",
        as_attachment=True,
        mimetype="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    )


==== FILE: app\routes\transfer_routes.py ====
from flask import Blueprint, jsonify, request
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models.transfer_model import TransferModel

transfer_bp = Blueprint("transfers", __name__)


@transfer_bp.route("/", methods=["POST"])
@jwt_required()
def create_transfer():
    data = request.get_json()
    current_user = get_jwt_identity()

    required = ["employee_id", "target_type", "target_id"]
    if not all(k in data for k in required):
        return jsonify({"error": "Missing fields"}), 400

    try:
        new_id = TransferModel.create_request(data, current_user["id"])
        return jsonify({"success": True, "id": new_id, "message": "הבקשה נשלחה"}), 201
    except ValueError as e:
        return jsonify({"success": False, "error": str(e)}), 409
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500


@transfer_bp.route("/pending", methods=["GET"])
@jwt_required()
def get_pending():
    requests = TransferModel.get_pending_requests()
    return jsonify(requests)


@transfer_bp.route("/history", methods=["GET"])
@jwt_required()
def get_history():
    history = TransferModel.get_history()
    return jsonify(history)


@transfer_bp.route("/<int:req_id>/approve", methods=["POST"])
@jwt_required()
def approve(req_id):
    current_user = get_jwt_identity()
    if TransferModel.approve_request(req_id, current_user["id"]):
        return jsonify({"success": True, "message": "הבקשה אושרה"})
    return jsonify({"success": False, "error": "Failed to approve"}), 500


@transfer_bp.route("/<int:req_id>/reject", methods=["POST"])
@jwt_required()
def reject(req_id):
    current_user = get_jwt_identity()
    data = request.get_json() or {}
    reason = data.get("reason", "")

    if TransferModel.reject_request(req_id, current_user["id"], reason):
        return jsonify({"success": True, "message": "הבקשה נדחתה"})
    return jsonify({"success": False, "error": "Failed to reject"}), 500


@transfer_bp.route("/<int:req_id>/cancel", methods=["POST"])
@jwt_required()
def cancel_transfer(req_id):
    current_user = get_jwt_identity()
    if TransferModel.cancel_request(
        req_id, current_user["id"], current_user["is_admin"]
    ):
        return jsonify({"success": True, "message": "Cancelled"})
    return jsonify({"success": False, "error": "Failed or Unauthorized"}), 400


==== FILE: app\routes\__init__.py ====


==== FILE: app\utils\db.py ====
import psycopg2
from psycopg2.extras import RealDictCursor
from flask import current_app, g

def get_db_connection():
    """יצירת חיבור למסד הנתונים"""
    try:
        conn = psycopg2.connect(
            host=current_app.config['DB_HOST'],
            database=current_app.config['DB_NAME'],
            user=current_app.config['DB_USER'],
            password=current_app.config['DB_PASS']
        )
        return conn
    except Exception as e:
        print(f"ERROR: Database connection failed: {e}")
        return None

def get_db():
    """חיבור לשימוש בתוך בקשה (Request context)"""
    if 'db' not in g:
        g.db = get_db_connection()
    return g.db

def close_db(e=None):
    """סגירת החיבור בסיום הבקשה"""
    db = g.pop('db', None)
    if db is not None:
        db.close()

==== FILE: app\utils\json_provider.py ====
from flask.json.provider import DefaultJSONProvider
from datetime import date, datetime

class CustomJSONProvider(DefaultJSONProvider):
    def default(self, obj):
        # המרה אוטומטית של תאריכים למחרוזת כדי למנוע שגיאות ב-JSON
        if isinstance(obj, (date, datetime)):
            return obj.isoformat()
        return super().default(obj)

==== FILE: app\utils\setup.py ====
from app.utils.db import get_db_connection
from werkzeug.security import generate_password_hash

def setup_database():
    """הרצת סקריפט הקמת הטבלאות והנתונים הראשוניים"""
    conn = get_db_connection()
    if not conn:
        print("Failed to connect to DB for setup.")
        return

    try:
        cur = conn.cursor()
        
        # 1. יצירת טבלאות תשתית (ללא מפתחות זרים עדיין למניעת מעגליות)
        tables = [
            """CREATE TABLE IF NOT EXISTS departments (
                id SERIAL PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                commander_id INTEGER
            );""",
            """CREATE TABLE IF NOT EXISTS sections (
                id SERIAL PRIMARY KEY,
                department_id INTEGER,
                name VARCHAR(100) NOT NULL,
                commander_id INTEGER
            );""",
            """CREATE TABLE IF NOT EXISTS teams (
                id SERIAL PRIMARY KEY,
                section_id INTEGER,
                name VARCHAR(100) NOT NULL,
                commander_id INTEGER
            );""",
            """CREATE TABLE IF NOT EXISTS roles (
                id SERIAL PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                description TEXT
            );""",
            """CREATE TABLE IF NOT EXISTS service_types (
                id SERIAL PRIMARY KEY,
                name VARCHAR(50) NOT NULL
            );""",
            """CREATE TABLE IF NOT EXISTS status_types (
                id SERIAL PRIMARY KEY,
                name VARCHAR(50) NOT NULL,
                color VARCHAR(20),
                is_presence BOOLEAN DEFAULT FALSE
            );""",
            """CREATE TABLE IF NOT EXISTS employees (
                id SERIAL PRIMARY KEY,
                personal_number VARCHAR(20) UNIQUE NOT NULL,
                national_id VARCHAR(9) UNIQUE,
                first_name VARCHAR(50) NOT NULL,
                last_name VARCHAR(50) NOT NULL,
                phone_number VARCHAR(20),
                password_hash VARCHAR(255),
                must_change_password BOOLEAN DEFAULT FALSE,
                is_admin BOOLEAN DEFAULT FALSE,
                is_commander BOOLEAN DEFAULT FALSE,
                is_active BOOLEAN DEFAULT TRUE,
                
                team_id INTEGER,
                role_id INTEGER,
                service_type_id INTEGER,
                
                birth_date DATE,
                enlistment_date DATE,
                discharge_date DATE,
                city VARCHAR(100),
                security_clearance INTEGER DEFAULT 0,
                emergency_contact VARCHAR(100),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );""",
            """CREATE TABLE IF NOT EXISTS attendance_logs (
                id BIGSERIAL PRIMARY KEY,
                employee_id INTEGER REFERENCES employees(id),
                status_type_id INTEGER REFERENCES status_types(id),
                start_datetime TIMESTAMP NOT NULL,
                end_datetime TIMESTAMP,
                note TEXT,
                reported_by INTEGER REFERENCES employees(id),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            );""",
            """CREATE TABLE IF NOT EXISTS transfer_requests (
                id SERIAL PRIMARY KEY,
                employee_id INTEGER REFERENCES employees(id),
                requester_id INTEGER REFERENCES employees(id),
                target_type VARCHAR(20) NOT NULL, 
                target_id INTEGER NOT NULL,
                status VARCHAR(20) DEFAULT 'pending',
                notes TEXT,
                rejection_reason TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                resolved_at TIMESTAMP,
                resolved_by INTEGER REFERENCES employees(id)
            );"""
        ]

        for table in tables:
            cur.execute(table)

        # 2. הזרקת נתוני בסיס (Roles, Statuses)
        cur.execute("SELECT COUNT(*) FROM roles")
        if cur.fetchone()[0] == 0:
            cur.execute("INSERT INTO roles (name) VALUES ('מנהל מערכת'), ('מפקד'), ('חייל')")
            
        cur.execute("SELECT COUNT(*) FROM status_types")
        if cur.fetchone()[0] == 0:
            cur.execute("""
                INSERT INTO status_types (name, color, is_presence) VALUES 
                ('משרד', '#22c55e', TRUE),
                ('חופשה', '#3b82f6', FALSE),
                ('מחלה', '#ef4444', FALSE),
                ('קורס', '#8b5cf6', TRUE),
                ('תגבור', '#f59e0b', TRUE),
                ('חו"ל', '#0ea5e9', FALSE)
            """)

        # 3. יצירת Admin דיפולטיבי (אם לא קיים)
        cur.execute("SELECT * FROM employees WHERE is_admin = TRUE")
        if not cur.fetchone():
            pw_hash = generate_password_hash("123456")
            cur.execute("""
                INSERT INTO employees 
                (first_name, last_name, personal_number, national_id, password_hash, is_admin, is_commander, must_change_password)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
            """, ('Admin', 'System', 'admin', '000000000', pw_hash, True, True, False))
            print("✅ Default Admin created: User: admin, Pass: 123456")

        conn.commit()
        print("✅ Database setup completed successfully.")
        
    except Exception as e:
        print(f"❌ Database setup failed: {e}")
        conn.rollback()
    finally:
        conn.close()

==== FILE: app\utils\__init__.py ====


==== FILE: app\__init__.py ====
from flask import Flask
from flask_cors import CORS
from flask_jwt_extended import JWTManager
from app.config import Config
from app.utils.json_provider import CustomJSONProvider
from app.utils.setup import setup_database


def create_app():
    app = Flask(__name__)
    app.config.from_object(Config)

    app.json = CustomJSONProvider(app)

    # Allow CORS for React frontend (usually runs on port 5173 or 3000)
    CORS(app, resources={r"/api/*": {"origins": "*"}})

    jwt = JWTManager(app)

    from app.utils.db import close_db

    app.teardown_appcontext(close_db)

    # Initialize DB (Tables + Admin)
    with app.app_context():
        setup_database()

    # Register Blueprints
    from app.routes.auth_routes import auth_bp
    from app.routes.employee_routes import emp_bp
    from app.routes.attendance_routes import att_bp
    from app.routes.transfer_routes import transfer_bp

    app.register_blueprint(auth_bp, url_prefix="/api/auth")
    app.register_blueprint(emp_bp, url_prefix="/api/employees")
    app.register_blueprint(att_bp, url_prefix="/api/attendance")
    app.register_blueprint(transfer_bp, url_prefix="/api/transfers")

    return app


==== FILE: requirements.txt ====
﻿Flask==3.0.0
flask-cors==4.0.0
flask-jwt-extended==4.6.0
psycopg2-binary==2.9.9
python-dotenv==1.0.0
Werkzeug==3.0.1
pandas==2.2.0
openpyxl==3.1.2

==== FILE: run.py ====
from app import create_app

app = create_app()

if __name__ == '__main__':
    # הרצת השרת במצב דיבאג
    app.run(debug=True, port=5000)

